"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractFactory = exports.Contract = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
var ethers_2 = require("ethers");
Object.defineProperty(exports, "Contract", { enumerable: true, get: function () { return ethers_2.Contract; } });
class ContractFactory extends ethers_1.ethers.ContractFactory {
    constructor(abi, bytecode, signer) {
        super(abi, bytecode, signer);
    }
    getDeployTransaction(...args) {
        var _a, _b;
        var _c;
        const txRequest = super.getDeployTransaction(...args);
        if (this.interface.deploy.inputs.length + 1 == args.length) {
            // pop out the overrides
            args.pop();
        }
        // Salt argument is not used, so we provide a placeholder value.
        const salt = '0x0000000000000000000000000000000000000000000000000000000000000000';
        const bytecodeHash = (0, utils_1.hashBytecode)(this.bytecode);
        const value = ethers_1.BigNumber.from(0); // TODO: add support for msg.value on the SDK side
        const constructorCalldata = ethers_1.utils.arrayify(this.interface.encodeDeploy(args));
        const deployCalldata = utils_1.CONTRACT_DEPLOYER.encodeFunctionData('create', [
            salt,
            bytecodeHash,
            value,
            constructorCalldata
        ]);
        txRequest.to = utils_1.CONTRACT_DEPLOYER_ADDRESS;
        txRequest.data = deployCalldata;
        (_a = txRequest.customData) !== null && _a !== void 0 ? _a : (txRequest.customData = {});
        (_b = (_c = txRequest.customData).factoryDeps) !== null && _b !== void 0 ? _b : (_c.factoryDeps = []);
        txRequest.customData.factoryDeps.push(this.bytecode);
        return txRequest;
    }
    async deploy(...args) {
        const contract = await super.deploy(...args);
        const deployTxReceipt = await contract.deployTransaction.wait();
        // Find the contract deployment event, it *must* be there.
        const deployedAddresses = deployTxReceipt.logs.filter((log) => log.topics[0] == ethers_1.utils.id('ContractDeployed(address,bytes32,address)'));
        // Take the last topic (deployed contract address as U256) and extract address from it (U160).
        const addressTopic = deployedAddresses[deployedAddresses.length - 1].topics[3];
        const addressByteLen = 40;
        const rawAddress = `0x${addressTopic.slice(addressTopic.length - addressByteLen)}`;
        // Transform into a Checksum Address for proper formatting.
        const deployAddress = ethers_1.utils.getAddress(rawAddress);
        const contractWithCorrectAddress = new ethers_1.ethers.Contract(deployAddress, contract.interface, contract.signer);
        ethers_1.utils.defineReadOnly(contractWithCorrectAddress, 'deployTransaction', contract.deployTransaction);
        return contractWithCorrectAddress;
    }
}
exports.ContractFactory = ContractFactory;
